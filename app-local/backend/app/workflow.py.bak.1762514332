from langgraph.graph import StateGraph, END
from typing import TypedDict
from app.models import Processo, DecisionResponse
from app.observability import langsmith_enabled
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import JsonOutputParser
from app.llm_service import llm

print(f"üîç Workflow - LangSmith habilitado: {langsmith_enabled}")

class WorkflowState(TypedDict):
    processo: Processo
    decision: DecisionResponse | None

prompt = ChatPromptTemplate.from_messages([
    ("system", """Voc√™ √© um analista jur√≠dico especializado em an√°lise de processos para compra de cr√©ditos.  Avalie o processo conforme as POL√çTICAS DE NEG√ìCIO:  **Regra-base (elegibilidade)** POL-1: S√≥ compramos cr√©dito de processos transitados em julgado e em fase de execu√ß√£o (OBRIGAT√ìRIO) POL-2: Exigir valor de condena√ß√£o informado (OBRIGAT√ìRIO)  **Quando N√ÉO compramos o cr√©dito** POL-3: Valor de condena√ß√£o < R$ 1.000,00 ‚Üí REJEITAR POL-4: Condena√ß√µes na esfera trabalhista ‚Üí REJEITAR POL-5: √ìbito do autor sem habilita√ß√£o no invent√°rio ‚Üí REJEITAR POL-6: Substabelecimento sem reserva de poderes ‚Üí REJEITAR  **Honor√°rios** POL-7: Informar honor√°rios contratuais, periciais e sucumbenciais quando existirem (OBRIGAT√ìRIO)  **Qualidade** POL-8: Se faltar documento essencial (ex.: tr√¢nsito em julgado n√£o comprovado) ‚Üí INCOMPLETO  **DECIS√ïES POSS√çVEIS:** - "approved": Processo aprovado para compra - "rejected": Processo rejeitado - "incomplete": Documenta√ß√£o incompleta  **INSTRU√á√ïES:** 1. Analise TODOS os documentos e movimentos 2. Verifique TODAS as pol√≠ticas POL-1 a POL-8 3. Cite TODAS as pol√≠ticas relevantes na sua decis√£o 4. Seja claro e objetivo na justificativa  Retorne APENAS JSON no formato: {{   "decision": "approved|rejected|incomplete",   "rationale": "Justificativa clara citando as pol√≠ticas",   "citacoes": ["POL-X", "POL-Y", ...]}}"""),
    ("user", """Analise o processo abaixo:

{processo}

Retorne a decis√£o em JSON.""")
])

chain = prompt | llm | JsonOutputParser()

def analyze_node(state: WorkflowState) -> WorkflowState:
    processo_dict = state["processo"].model_dump()
    print(f"üìä Invocando LLM para processo: {processo_dict.get('numeroProcesso')}")
    result = chain.invoke({"processo": processo_dict})
    print(f"‚úÖ LLM respondeu: {result.get('decision')}")
    state["decision"] = DecisionResponse(**result)
    return state

def create_workflow() -> StateGraph:
    workflow = StateGraph(WorkflowState)
    workflow.add_node("analyze", analyze_node)
    workflow.set_entry_point("analyze")
    workflow.add_edge("analyze", END)
    return workflow.compile()

app_workflow = create_workflow()