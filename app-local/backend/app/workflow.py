from langgraph.graph import StateGraph, END
from typing import TypedDict
from app.models import Processo, DecisionResponse
from app.observability import langsmith_enabled
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import JsonOutputParser
from app.llm_service import llm

print(f"üîç Workflow - LangSmith habilitado: {langsmith_enabled}")

class WorkflowState(TypedDict):
    processo: Processo
    decision: DecisionResponse | None

prompt = ChatPromptTemplate.from_messages([
    ("system", """Voc√™ √© um analista jur√≠dico especializado em an√°lise de processos para compra de cr√©ditos.

Avalie o processo conforme as POL√çTICAS DE NEG√ìCIO:

**Regra-base (elegibilidade)**
POL-1: S√≥ compramos cr√©dito de processos transitados em julgado e em fase de execu√ß√£o (OBRIGAT√ìRIO)
POL-2: Exigir valor de condena√ß√£o informado (OBRIGAT√ìRIO)

**Quando N√ÉO compramos o cr√©dito**
POL-3: Valor de condena√ß√£o < R$ 1.000,00 ‚Üí REJEITAR
POL-4: Condena√ß√µes na esfera trabalhista ‚Üí REJEITAR
POL-5: √ìbito do autor sem habilita√ß√£o no invent√°rio ‚Üí REJEITAR
POL-6: Substabelecimento sem reserva de poderes ‚Üí REJEITAR

**Honor√°rios**
POL-7: Informar honor√°rios contratuais, periciais e sucumbenciais quando existirem (OBRIGAT√ìRIO)

**Qualidade**
POL-8: Se faltar documento essencial (ex.: tr√¢nsito em julgado n√£o comprovado) ‚Üí INCOMPLETO

**DECIS√ïES POSS√çVEIS:**
- "approved": Processo aprovado para compra
- "rejected": Processo rejeitado
- "incomplete": Documenta√ß√£o incompleta

**INSTRU√á√ïES:**
1. Analise TODOS os documentos e movimentos
2. Verifique TODAS as pol√≠ticas POL-1 a POL-8
3. Cite TODAS as pol√≠ticas relevantes na sua decis√£o
4. Seja claro e objetivo na justificativa

Retorne APENAS JSON no formato:
{{
  "decision": "approved|rejected|incomplete",
  "rationale": "Justificativa clara citando as pol√≠ticas",
  "citacoes": ["POL-X", "POL-Y", ...]
}}"""),
    ("user", """Analise o processo abaixo:

{processo}

Retorne a decis√£o em JSON.""")
])

chain = prompt | llm | JsonOutputParser()

def analyze_node(state: WorkflowState) -> WorkflowState:
    processo_dict = state["processo"].model_dump()
    print(f"üìä Invocando LLM para processo: {processo_dict.get('numeroProcesso')}")
    result = chain.invoke({"processo": processo_dict})
    print(f"‚úÖ LLM respondeu: {result.get('decision')}")
    state["decision"] = DecisionResponse(**result)
    return state

def create_workflow() -> StateGraph:
    workflow = StateGraph(WorkflowState)
    workflow.add_node("analyze", analyze_node)
    workflow.set_entry_point("analyze")
    workflow.add_edge("analyze", END)
    return workflow.compile()

app_workflow = create_workflow()